{"ast":null,"code":"import _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport React from \"react\";\nimport set from \"lodash/set\";\nimport has from \"lodash/has\";\n\nconst enhancedReducer = (state, updateArg) => {\n  // check if the type of update argument is a callback function\n  if (updateArg.constructor === Function) {\n    return _objectSpread({}, state, updateArg(state));\n  } // if the type of update argument is an object\n\n\n  if (updateArg.constructor === Object) {\n    // does the update object have _path and _value as it's keys\n    // if yes then use them to update deep object values\n    if (has(updateArg, \"_path\") && has(updateArg, \"_value\")) {\n      const {\n        _path,\n        _value\n      } = updateArg;\n      return produce(state, draft => {\n        set(draft, _path, _value);\n      });\n    } else {\n      return _objectSpread({}, state, updateArg);\n    }\n  }\n};\n\nconst useFormState = initialState => {\n  const [state, updateState] = React.useReducer(enhancedReducer, initialState);\n  const updateForm = React.useCallback(({\n    target: {\n      value,\n      name,\n      type\n    }\n  }) => {\n    const updatePath = name.split(\".\"); // if the input is a checkbox then use callback function to update\n    // the toggle state based on previous state\n\n    if (type === \"checkbox\") {\n      updateState(prevState => ({\n        [name]: !prevState[name]\n      }));\n      return;\n    } // if we have to update the root level nodes in the form\n\n\n    if (updatePath.length === 1) {\n      const [key] = updatePath;\n      updateState({\n        [key]: value\n      });\n    } // if we have to update nested nodes in the form object\n    // use _path and _value to update them.\n\n\n    if (updatePath.length === 2) {\n      updateState({\n        _path: updatePath,\n        _value: value\n      });\n    }\n  }, []);\n  return [state, updateForm];\n};\n\nexport default useFormState;","map":null,"metadata":{},"sourceType":"module"}