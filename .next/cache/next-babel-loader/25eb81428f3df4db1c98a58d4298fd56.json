{"ast":null,"code":"import _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _objectSpread from \"@babel/runtime-corejs2/helpers/esm/objectSpread\";\nimport React from \"react\";\nimport set from \"lodash/set\";\nimport has from \"lodash/has\";\n\nvar enhancedReducer = function enhancedReducer(state, updateArg) {\n  // check if the type of update argument is a callback function\n  if (updateArg.constructor === Function) {\n    return _objectSpread({}, state, updateArg(state));\n  } // if the type of update argument is an object\n\n\n  if (updateArg.constructor === Object) {\n    // does the update object have _path and _value as it's keys\n    // if yes then use them to update deep object values\n    if (has(updateArg, \"_path\") && has(updateArg, \"_value\")) {\n      var _path = updateArg._path,\n          _value = updateArg._value;\n      return produce(state, function (draft) {\n        set(draft, _path, _value);\n      });\n    } else {\n      return _objectSpread({}, state, updateArg);\n    }\n  }\n};\n\nvar useFormState = function useFormState(initialState) {\n  var _React$useReducer = React.useReducer(enhancedReducer, initialState),\n      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n      state = _React$useReducer2[0],\n      updateState = _React$useReducer2[1];\n\n  var updateForm = React.useCallback(function (_ref) {\n    var _ref$target = _ref.target,\n        value = _ref$target.value,\n        name = _ref$target.name,\n        type = _ref$target.type;\n    var updatePath = name.split(\".\"); // if the input is a checkbox then use callback function to update\n    // the toggle state based on previous state\n\n    if (type === \"checkbox\") {\n      updateState(function (prevState) {\n        return _defineProperty({}, name, !prevState[name]);\n      });\n      return;\n    } // if we have to update the root level nodes in the form\n\n\n    if (updatePath.length === 1) {\n      var _updatePath = _slicedToArray(updatePath, 1),\n          key = _updatePath[0];\n\n      updateState(_defineProperty({}, key, value));\n    } // if we have to update nested nodes in the form object\n    // use _path and _value to update them.\n\n\n    if (updatePath.length === 2) {\n      updateState({\n        _path: updatePath,\n        _value: value\n      });\n    }\n  }, []);\n  return [state, updateForm];\n};\n\nexport default useFormState;","map":{"version":3,"sources":["/Users/alexiastandish/Desktop/Freelance Clients/NewportMed/newportmed/components/contact-section/contact-form/form-state.js"],"names":["React","set","has","enhancedReducer","state","updateArg","constructor","Function","Object","_path","_value","produce","draft","useFormState","initialState","useReducer","updateState","updateForm","useCallback","target","value","name","type","updatePath","split","prevState","length","key"],"mappings":";;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,GAAP,MAAgB,YAAhB;AACA,OAAOC,GAAP,MAAgB,YAAhB;;AAEA,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAACC,KAAD,EAAQC,SAAR,EAAsB;AAC5C;AACA,MAAIA,SAAS,CAACC,WAAV,KAA0BC,QAA9B,EAAwC;AACtC,6BAAYH,KAAZ,EAAsBC,SAAS,CAACD,KAAD,CAA/B;AACD,GAJ2C,CAM5C;;;AACA,MAAIC,SAAS,CAACC,WAAV,KAA0BE,MAA9B,EAAsC;AACpC;AACA;AACA,QAAIN,GAAG,CAACG,SAAD,EAAY,OAAZ,CAAH,IAA2BH,GAAG,CAACG,SAAD,EAAY,QAAZ,CAAlC,EAAyD;AAAA,UAC/CI,KAD+C,GAC7BJ,SAD6B,CAC/CI,KAD+C;AAAA,UACxCC,MADwC,GAC7BL,SAD6B,CACxCK,MADwC;AAGvD,aAAOC,OAAO,CAACP,KAAD,EAAQ,UAAAQ,KAAK,EAAI;AAC7BX,QAAAA,GAAG,CAACW,KAAD,EAAQH,KAAR,EAAeC,MAAf,CAAH;AACD,OAFa,CAAd;AAGD,KAND,MAMO;AACL,+BAAYN,KAAZ,EAAsBC,SAAtB;AACD;AACF;AACF,CApBD;;AAsBA,IAAMQ,YAAY,GAAG,SAAfA,YAAe,CAAAC,YAAY,EAAI;AAAA,0BACNd,KAAK,CAACe,UAAN,CAAiBZ,eAAjB,EAAkCW,YAAlC,CADM;AAAA;AAAA,MAC5BV,KAD4B;AAAA,MACrBY,WADqB;;AAGnC,MAAMC,UAAU,GAAGjB,KAAK,CAACkB,WAAN,CAAkB,gBAAuC;AAAA,2BAApCC,MAAoC;AAAA,QAA1BC,KAA0B,eAA1BA,KAA0B;AAAA,QAAnBC,IAAmB,eAAnBA,IAAmB;AAAA,QAAbC,IAAa,eAAbA,IAAa;AAC1E,QAAMC,UAAU,GAAGF,IAAI,CAACG,KAAL,CAAW,GAAX,CAAnB,CAD0E,CAG1E;AACA;;AACA,QAAIF,IAAI,KAAK,UAAb,EAAyB;AACvBN,MAAAA,WAAW,CAAC,UAAAS,SAAS;AAAA,mCAClBJ,IADkB,EACX,CAACI,SAAS,CAACJ,IAAD,CADC;AAAA,OAAV,CAAX;AAIA;AACD,KAXyE,CAa1E;;;AACA,QAAIE,UAAU,CAACG,MAAX,KAAsB,CAA1B,EAA6B;AAAA,uCACbH,UADa;AAAA,UACpBI,GADoB;;AAG3BX,MAAAA,WAAW,qBACRW,GADQ,EACFP,KADE,EAAX;AAGD,KApByE,CAsB1E;AACA;;;AACA,QAAIG,UAAU,CAACG,MAAX,KAAsB,CAA1B,EAA6B;AAC3BV,MAAAA,WAAW,CAAC;AACVP,QAAAA,KAAK,EAAEc,UADG;AAEVb,QAAAA,MAAM,EAAEU;AAFE,OAAD,CAAX;AAID;AACF,GA9BkB,EA8BhB,EA9BgB,CAAnB;AAgCA,SAAO,CAAChB,KAAD,EAAQa,UAAR,CAAP;AACD,CApCD;;AAsCA,eAAeJ,YAAf","sourcesContent":["import React from \"react\";\nimport set from \"lodash/set\";\nimport has from \"lodash/has\";\n\nconst enhancedReducer = (state, updateArg) => {\n  // check if the type of update argument is a callback function\n  if (updateArg.constructor === Function) {\n    return { ...state, ...updateArg(state) };\n  }\n\n  // if the type of update argument is an object\n  if (updateArg.constructor === Object) {\n    // does the update object have _path and _value as it's keys\n    // if yes then use them to update deep object values\n    if (has(updateArg, \"_path\") && has(updateArg, \"_value\")) {\n      const { _path, _value } = updateArg;\n\n      return produce(state, draft => {\n        set(draft, _path, _value);\n      });\n    } else {\n      return { ...state, ...updateArg };\n    }\n  }\n};\n\nconst useFormState = initialState => {\n  const [state, updateState] = React.useReducer(enhancedReducer, initialState);\n\n  const updateForm = React.useCallback(({ target: { value, name, type } }) => {\n    const updatePath = name.split(\".\");\n\n    // if the input is a checkbox then use callback function to update\n    // the toggle state based on previous state\n    if (type === \"checkbox\") {\n      updateState(prevState => ({\n        [name]: !prevState[name]\n      }));\n\n      return;\n    }\n\n    // if we have to update the root level nodes in the form\n    if (updatePath.length === 1) {\n      const [key] = updatePath;\n\n      updateState({\n        [key]: value\n      });\n    }\n\n    // if we have to update nested nodes in the form object\n    // use _path and _value to update them.\n    if (updatePath.length === 2) {\n      updateState({\n        _path: updatePath,\n        _value: value\n      });\n    }\n  }, []);\n\n  return [state, updateForm];\n};\n\nexport default useFormState;\n"]},"metadata":{},"sourceType":"module"}